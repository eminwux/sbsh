/*
Copyright Â© 2025 Emiliano Spinella (eminwux)
*/

package llm

import (
	"bufio"
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"os/exec"
	"strings"
	"syscall"
	"time"
)

// ------------- CONFIGURATION -------------

var openaiAPIKey string
var openaiModel string = "gpt-4o"
var openaiEndpoint string = "https://api.openai.com/v1/chat/completions"

// ------------- UTILS -------------
// Init configures the package variables. Only overrides defaults if the input is non-empty.
// Returns an error if the API key is empty.
func Init(apiKey, model, endpoint string) error {
	if apiKey == "" {
		return errors.New("OpenAI API key must be provided")
	}
	openaiAPIKey = apiKey

	if model != "" {
		openaiModel = model
	}
	if endpoint != "" {
		openaiEndpoint = endpoint
	}
	return nil
}

func askYesNo(prompt string) bool {
	answer := ReadLine(prompt + " (y/n): ")
	return strings.HasPrefix(strings.ToLower(answer), "y")
}

// ------------- OPENAI API -------------

type ChatMessage struct {
	Role    string `json:"role"`
	Content string `json:"content"`
}

type ChatRequest struct {
	Model       string        `json:"model"`
	Messages    []ChatMessage `json:"messages"`
	MaxTokens   int           `json:"max_tokens"`
	Temperature float64       `json:"temperature"`
}

type ChatResponse struct {
	Choices []struct {
		Message struct {
			Content string `json:"content"`
		} `json:"message"`
	} `json:"choices"`
}

func openaiChatCompletion(prompt string, maxTokens int) (string, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 60*time.Second)
	defer cancel()

	reqBody, _ := json.Marshal(ChatRequest{
		Model:       openaiModel,
		Messages:    []ChatMessage{{Role: "user", Content: prompt}},
		MaxTokens:   maxTokens,
		Temperature: 0,
	})

	req, _ := http.NewRequestWithContext(ctx, "POST", openaiEndpoint, bytes.NewBuffer(reqBody))
	req.Header.Add("Authorization", "Bearer "+openaiAPIKey)
	req.Header.Add("Content-Type", "application/json")

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()
	body, _ := ioutil.ReadAll(resp.Body)

	var response ChatResponse
	if err := json.Unmarshal(body, &response); err != nil {
		return "", err
	}
	if len(response.Choices) == 0 {
		return "", fmt.Errorf("No response from OpenAI")
	}
	return cleanBashScript(response.Choices[0].Message.Content), nil
}

// Remove markdown code fences
func cleanBashScript(script string) string {
	lines := strings.Split(strings.TrimSpace(script), "\n")
	if len(lines) > 0 && strings.HasPrefix(strings.TrimSpace(lines[0]), "```") {
		lines = lines[1:]
	}
	if len(lines) > 0 && strings.HasPrefix(strings.TrimSpace(lines[len(lines)-1]), "```") {
		lines = lines[:len(lines)-1]
	}
	return strings.Join(lines, "\n")
}

// ------------- MAIN LOGIC -------------

func getBashScriptFromOpenAI(need string) (string, error) {
	prompt := `
DO NOT use any markdown, triple backticks, or comments in your answer. 
ONLY output the plain Bash script, nothing else. 
Do NOT use 'sudo' in any command.
You are a Linux DevOps engineer. For the following requirement, generate ONLY the content of a complete Bash script. 
For each operation:
 1- Echo a description of what is being done in yellow.
 2- Echo the exact command that will be executed in blue.
 3- Execute the command, capturing both standard output and standard error.
 4- Echo a description of what the output represents in yellow.
 5- If the command succeeds and generates output, print it in green.
 6- If the command fails and there is error output, print it in red.
 7- If the command generates no output at all (neither stdout nor stderr), print a message in cyan saying 'No output generated by the command.'
Use ANSI color codes for yellow (description), blue (command), green (output), red (error), and cyan (no output). 
Separate each step clearly.
Requirement: '` + need + `'`
	return openaiChatCompletion(prompt, 900)
}

const ScriptTimeout = 30 * time.Second // 30 seconds timeout

func executeBashScript(script string) (string, string) {
	tmpfile, err := os.CreateTemp("", "sbsh-script-*.sh")
	if err != nil {
		return "", "Failed to create temp script"
	}
	defer os.Remove(tmpfile.Name())
	tmpfile.WriteString(script)
	tmpfile.Close()
	os.Chmod(tmpfile.Name(), 0755)

	ctx, cancel := context.WithTimeout(context.Background(), ScriptTimeout)
	defer cancel()

	cmd := exec.CommandContext(ctx, "/bin/bash", tmpfile.Name())

	// Start bash in its own process group
	cmd.SysProcAttr = &syscall.SysProcAttr{
		Setpgid: true,
	}

	var outBuf, errBuf bytes.Buffer
	cmd.Stdout = &outBuf
	cmd.Stderr = &errBuf

	// Start command
	err = cmd.Start()
	if err != nil {
		return "", "Failed to start command: " + err.Error()
	}

	done := make(chan error)
	go func() { done <- cmd.Wait() }()

	select {
	case <-ctx.Done():
		// Timeout happened: kill the process group
		_ = syscall.Kill(-cmd.Process.Pid, syscall.SIGKILL)
		return outBuf.String(), "Script execution timed out\n"
	case err := <-done:
		if err != nil {
			return outBuf.String(), errBuf.String() + "\n" + err.Error()
		}
		return outBuf.String(), errBuf.String()
	}
}

func getConclusionFromOpenAI(need, script, scriptOutput string) (string, error) {
	prompt := `
You are a Linux administrator assistant.
Given the following:
User requirement:
` + need + `

Bash script executed:
` + script + `

Script output:
` + scriptOutput + `

Provide your answer in three fields:
1. Exit message: a short actionable phrase or sentence.
2. Description: a concise summary (1-2 sentences) of what was checked and what was found.
3. Follow-up need for script: If there is a clear Bash command or step that can fix an error, write a one-sentence natural language requirement for a follow-up Bash script to solve the problem (leave this field empty if not applicable).
Format your answer as:
Exit message: <short exit message>
Description: <concise summary>
Follow-up need for script: <follow-up request or leave blank>`
	return openaiChatCompletion(prompt, 250)
}

func parseConclusion(response string) (exitMessage, description, followUpNeed string) {
	lines := strings.Split(response, "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(strings.ToLower(line), "exit message:") {
			exitMessage = strings.TrimSpace(line[len("exit message:"):])
		} else if strings.HasPrefix(strings.ToLower(line), "description:") {
			description = strings.TrimSpace(line[len("description:"):])
		} else if strings.HasPrefix(strings.ToLower(line), "follow-up need for script:") {
			followUpNeed = strings.TrimSpace(line[len("follow-up need for script:"):])
		}
	}
	return
}

func ReadLine(prompt string) string {
	fmt.Print(prompt)
	scanner := bufio.NewScanner(os.Stdin)
	if scanner.Scan() {
		return strings.TrimSpace(scanner.Text())
	}
	return ""
}

func Run(need string) {

	// Step 1: Get Bash script from OpenAI
	script, err := getBashScriptFromOpenAI(need)
	if err != nil {
		fmt.Println("Error getting script from OpenAI:", err)
		return
	}
	fmt.Println("\nGenerated Bash script:\n" + strings.Repeat("=", 30))
	fmt.Println(script)
	fmt.Println(strings.Repeat("=", 30))

	// Step 2 Ask user if want to execute
	if !askYesNo("Do you want to execute this script?") {
		fmt.Println("Script execution canceled by user.")
		return
	}
	output, errorOutput := executeBashScript(script)
	fmt.Println("\n--- Script Output ---")
	fmt.Print(output)
	if errorOutput != "" {
		fmt.Println("\n--- Script Error ---")
		fmt.Print(errorOutput)
	}

	// Step 3: Get conclusion from OpenAI
	conclusion, err := getConclusionFromOpenAI(need, script, output+errorOutput)
	if err != nil {
		fmt.Println("Error getting conclusion from OpenAI:", err)
		return
	}
	exitMsg, desc, followUpNeed := parseConclusion(conclusion)
	fmt.Println("\n[Conclusion]")
	fmt.Println("Exit message:", exitMsg)
	fmt.Println("Description:", desc)

	// Step 4: Handle follow-up
	if followUpNeed != "" {
		fmt.Println("\nA follow-up script is suggested to fix the detected issue.")
		fmt.Println("Follow-up need:", followUpNeed)

		followUpScript, err := getBashScriptFromOpenAI(followUpNeed)
		if err != nil {
			fmt.Println("Error getting follow-up script from OpenAI:", err)
			return
		}
		fmt.Println("\nGenerated follow-up Bash script:\n" + strings.Repeat("=", 30))
		fmt.Println(followUpScript)
		fmt.Println(strings.Repeat("=", 30))
		if askYesNo("Do you want to execute this follow-up script?") {
			followUpOut, followUpErr := executeBashScript(followUpScript)
			fmt.Println("\n--- Follow-up Script Output ---")
			fmt.Print(followUpOut)
			if followUpErr != "" {
				fmt.Println("\n--- Script Error ---")
				fmt.Print(followUpErr)
			}
		} else {
			fmt.Println("Follow-up script execution canceled by user.")
		}
	} else {
		fmt.Println("\nNo follow-up action required.")
	}
}
